---
sidebar_position: 5
---

# 动作变量

在物品动作中，你可以使用[即时声明节点](随机节点/即时声明节点.md)，并通过特殊的物品节点调用物品的nbt及节点缓存。

## 节点一览

| 节点类型 | 含义 |
| :----: | :----: |
| nbt::参数 | 物品NBT |
| data::参数 | 物品节点内容 |
| amount:: | 物品数量 |
| type:: | 物品材质(比如STONE, DIAMOND) |
| damage:: | 物品子ID/损伤值 |
| 即时声明节点类型:: | 可以使用所有即时声明节点(比如strings::参数, weight::参数) |
| global中的内容 | 通过key调用js中global的内容, 形如<test>, 代表调用global.test |

## 格式

`<节点类型::参数1_参数2_参数3...>`

即时声明节点无法指定节点ID, 如有需求，请配置私有/全局节点

节点参数中的`_`请用`\_`代替, 避免被当做参数分隔符, 这里的反斜杠不是转义符, 因此请注意当前最外层括号的引号类型

yaml语法中双引号包裹的`\`代表转义符, `\\`才是反斜杠

单引号包裹的, 或没有引号包裹的`\`直接代表反斜杠

我在此列举所有情况, 供你参考:

```yaml
# 返回 test1 或 test2 或 test3
test1: <strings::test1_test2_test3>
# 返回 test1_test2 或 test3
test2: <strings::test1\_test2_test3>

# 返回 test1 或 test2 或 test3
test3: '<strings::test1_test2_test3>'
# 返回 test1_test2 或 test3
test4: '<strings::test1\_test2_test3>'

# 返回 test1 或 test2 或 test3
test5: "<strings::test1_test2_test3>"
# 返回 test1?test2 或 test3 此处的?是一种特殊字符, 代表被转义的_
test6: "<strings::test1\_test2_test3>"
# 返回 test1_test2 或 test3
test7: "<strings::test1\\_test2_test3>"
```

:::caution

很多情况下下, 对于连续的反斜杠, 最终呈现的数量为"总数/2"向上取整

比如连续三个反斜杠, 除以2等于1.5, 向上取整后体现为2个

连续四个反斜杠, 除以2等于2, 向上取整后也体现为2个(因为2本来就是整数)

对于这种奇葩的操作, 我写一段示例:

```yaml
# 获取出来是 \
test1: \
# 获取出来是 \
test2: \\
# 获取出来是 \\
test3: \\\
# 获取出来是 \
test4: '\'
# 获取出来是 \
test5: '\\'
# 获取出来是 \\
test6: '\\\'
# 获取出来是 \
test7: "\\"
# 获取出来是 \
test8: "\\\\"
# 获取出来是 \\
test9: "\\\\\\"
```

具体是否遇到这种奇葩情况, 需要你自己判断, 我在此仅作提醒

:::

## nbt、data示例

以默认配置为例：

```yaml
actionTest:
  material: STONE
  nbt:
    test1: "666"
    test2: 
      test3: "777"
    test4:
    - "888"
    - "999"
  sections:
    test: "000"
```

```yaml
actionTest:
  all: 
  - "console: say 名为test1的NBT的值为: <nbt::test1>"
  - "console: say 名为test2.test3的NBT的值为: <nbt::test2.test3>"
  - "console: say 名为test4.0的NBT的值为: <nbt::test4.0>"
  - "console: say 名为test4.1的NBT的值为: <nbt::test4.1>"
  - "console: say 名为test的节点的值为: <data::test>"
```

后台返回值如下

```
[Server] 名为test1的NBT的值为: 666
[Server] 名为test2.test3的NBT的值为: 777
[Server] 名为test4.0的NBT的值为: 888
[Server] 名为test4.1的NBT的值为: 999
[Server] 名为test的节点的值为: 000
[Server] 随机数尝试: 0.74
```

用法类似于即时声明节点，data表示调用节点，nbt表示调用物品nbt。

一层一层id以小数点`.`分隔

如果id中存在`.`, 请在书写时通过`\.`代替, 这里的反斜杠不是转义符, 因此请注意当前最外层括号的引号类型

如:

```yaml
actionTest:
  all: 
  - "console: say <nbt::te\\.st1.test2>"
  - 'console: say <nbt::te\.st1.test2>'
```

上面两行动作取的都是`te.st1`下的`test2`的值

yaml语法中双引号包裹的`\`代表转义符, `\\`才是反斜杠

单引号包裹的, 或没有引号包裹的`\`直接代表反斜杠

## amount、type、damage示例

```yaml
test:
  all: 
  - "tell: 物品数量为: <amount::>"
  - "tell: 物品类型为: <type::>"
  - "tell: 物品子ID/损伤值为: <damage::>"
```

如上所示, 不要忘记添加`::`, 添加了`::`才代表调用对应节点类型, 而不是读取对应节点内容

## 即时声明节点示例

```yaml
test:
  all: 
  - "tell: 随机数: <number::0_10>"
```

如上所示, 只需要像即时声明节点一样写就可以了

## global调用示例

```yaml
test1:
  right:
    # 配置消耗信息
    consume:
      # 在准备消耗物品前, 记录物品的堆叠数量
      # itemStack.amount 代表物品的堆叠数量, 是一个数字
      # itemStack.amount + "" 代表将堆叠数量这个数字转换为字符串(数字 + 字符串 = 字符串)
      # global.amount = itemStack.amount + "" 代表将global中的amount定义为这段文本
      # 最后一行的true代表返回true, 让condition通过, 开始尝试消耗物品
      condition: |-
        global.amount = itemStack.amount + ""
        true
      # <amount>代表调用global中的amount
      # 这里也可以用<amount::>代替, 表示当前物品的数量
      # amount: <amount> 即代表消耗所有的物品
      amount: <amount>
    sync:
    # 执行这条动作后, 你将收到一条消息, 告诉你你所消耗物品的数量
    # 这里不能用<amount::>代替, 因为此时物品已经被全部消耗, 数量为0
    - 'tell: 你消耗了 <amount> 个物品'

test2:
  right:
    sync:
    # 在js动作中将global中的test定义为"测试"
    - 'js: global.test = "测试"'
    # 向你发送global中test的内容, 你将收到 测试
    - 'tell: <test>'
```

需要注意的是, 如果所调用global内容的返回值不是一段字符串(比如它是一个数字), 获取到的内容会变为null

比如:

```yaml
test3:
  right:
    sync:
    # 在js动作中将global中的test定义为1
    - 'js: global.test = 1'
    # 你将收到 <test>, 因为test的值是一个数字, 而不是字符串
    - 'tell: <test>'
```
