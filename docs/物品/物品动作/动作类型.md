---
sidebar_position: 3
---

# 动作类型

> 全部基础动作支持papi变量, 动作类型不区分大小写

## 动作写法

物品动作大致可归为四类: 列表式、字符式、条件式、循环式:

```yaml
# 字符式
actions: 'tell: 你好'
```

```yaml
# 列表式
actions:
- 'tell: 你好'
- 'tell: 你好'
- 'tell: 你好'
```

```yaml
# 条件式
actions:
  condition: 'perm("test")'
  actions:
  - 'tell: 你好'
  deny:
  - 'tell: 你好'
```

```yaml
# 循环式
actions:
  while: '循环条件'
  actions:
  - '满足条件执行的动作'
  finally:
  - '结束循环后执行的动作'
```

需要注意，在循环式中，当条件永远满足时，动作将进入死循环，因此需要注意摆脱循环，比如

```yaml
actions:
- 'setGlobal: index 0'
- while: 'global.index < 10'
  actions:
  - 'setGlobal: index <fastcalc::<index>+1>'
  - 'tell: 当前index: <index>'
  finally:
  - 'tell: 循环结束, 当前index: <index>'
```

或者通过return跳出循环, 比如

```yaml
actions:
- 'setGlobal: index 0'
- while: 'global.index < 10'
  actions:
  - 'setGlobal: index <fastcalc::<index>+1>'
  - 'tell: 当前index: <index>'
  - condition: global.index == 5
    actions:
    - return
  finally:
  - 'tell: 循环结束, 当前index: <index>'
```

这四种形式可以任意组合, 在此我仅作一例:

```yaml
# 列表式组合条件式
actions:
- 'tell: 你好'
- condition: 'perm("test")'
  actions:
  - 'tell: 你好'
  deny:
  - 'tell: 你好'
- 'tell: 你好'
```

## 发送文本

> 向玩家发送一条消息(可使用&作为颜色符号)

```yaml
- 'tell: &eHello'
```

## 发送文本

> 向玩家发送一条消息(不将&解析为颜色符号)

```yaml
- 'tellNoColor: §eHello, can you see "&"?'
```

## 强制聊天

> 强制玩家发送一条消息(不将&解析为颜色符号)

```yaml
- 'chat: see, I can send "&"!'
```

## 强制聊天

> 强制玩家发送一条消息(可使用&作为颜色符号)

```yaml
- 'chatWithColor: &eHello'
```

## 执行指令(玩家)

> 强制玩家执行一条指令(可使用&作为颜色符号)

```yaml
- 'command: say Hello'
- 'player: say Hello'
```

## 执行指令(玩家)

> 强制玩家执行一条指令(不将&解析为颜色符号)

```yaml
- 'commandNoColor: say Hello'
```

## 执行指令(后台)

> 后台执行一条指令(可使用&作为颜色符号)

```yaml
- 'console: say Hello'
```

## 执行指令(后台)

> 后台执行一条指令(不将&解析为颜色符号)

```yaml
- 'consoleNoColor: say Hello'
```

## 发送标题

> 向玩家发送一条标题(可使用&作为颜色符号)

```yaml
- 'title: Title SubTitle FadeIn Stay FadeOut'
```

* `Title` 主标题
* `SubTitle` 次标题, 默认为空
* `FadeIn` 标题显现消耗的时间(以tick为单位, 20tick = 1s), 默认10
* `Stay` 标题持续显示的时间(以tick为单位, 20tick = 1s), 默认70
* `FadeOut` 标题消失消耗的时间(以tick为单位, 20tick = 1s), 默认20

`SubTitle` `FadeIn` `Stay` `FadeOut`存在默认值, 可以不填写

参数之间以空格做分隔, 文本形式的空格需要通过反斜杠转义, 如:

```yaml
- 'title: 你好\ 我是你爹'
```

效果:

![](_images/标题1.png)

```yaml
- 'title: 你好 我是你爹'
```

效果:

![](_images/标题2.png)

## 发送标题

> 向玩家发送一条标题(不将&解析为颜色符号)

```yaml
- 'titleNoColor: Title SubTitle FadeIn Stay FadeOut'
```

* `Title` 主标题
* `SubTitle` 次标题
* `FadeIn` 标题显现消耗的时间(以tick为单位, 20tick = 1s), 默认10
* `Stay` 标题持续显示的时间(以tick为单位, 20tick = 1s), 默认70
* `FadeOut` 标题消失消耗的时间(以tick为单位, 20tick = 1s), 默认20

## 发送ActionBar

> 向玩家发送一条ActionBar消息(可使用&作为颜色符号)

```yaml
- 'actionBar: &eHello'
```

## 发送ActionBar

> 向玩家发送一条ActionBar消息(不将&解析为颜色符号)

```yaml
- 'actionBarNoColor: §eHello, can you see "&"?'
```

## 给予金币(Vault)

> 给予玩家一定数量金币

```yaml
- 'giveMoney: 100'
```

## 扣除金币(Vault)

> 扣除玩家一定数量金币

```yaml
- 'takeMoney: 100'
```

## 给予经验

> 给予玩家一定数量经验

```yaml
- 'giveExp: 100'
```

## 扣除经验

> 扣除玩家一定数量经验

```yaml
- 'takeExp: 100'
```

## 设置经验

> 设置玩家当前经验

```yaml
- 'setExp: 100'
```

## 给予经验等级

> 给予玩家一定数量经验等级

```yaml
- 'giveLevel: 100'
```

## 扣除经验等级

> 扣除玩家一定数量经验等级

```yaml
- 'takeLevel: 100'
```

## 设置经验等级

> 设置玩家当前经验等级

```yaml
- 'setLevel: 100'
```

## 给予饱食度

> 给予玩家一定数量饱食度

```yaml
- 'giveFood: 5'
```

## 扣除饱食度

> 扣除玩家一定数量饱食度

```yaml
- 'takeFood: 5'
```

## 设置饱食度

> 设置玩家当前饱食度

```yaml
- 'setFood: 20'
```

## 给予饱和度

> 给予玩家一定数量饱和度(玩家饱和度不能超过饱食度)

```yaml
- 'giveSaturation: 5'
```

## 扣除饱和度

> 扣除玩家一定数量饱和度(玩家饱和度不能超过饱食度)

```yaml
- 'takeSaturation: 5'
```

## 设置饱和度

> 设置玩家当前饱和度(玩家饱和度不能超过饱食度)

```yaml
- 'setSaturation: 20'
```

## 给予生命值

> 给予玩家一定数量生命值

```yaml
- 'giveHealth: 5'
```

## 扣除生命值

> 扣除玩家一定数量生命值

```yaml
- 'takeHealth: 5'
```

## 设置生命值

> 设置玩家当前生命值

```yaml
- 'setHealth: 20'
```

## 释放MM技能

> 释放MM技能, 对创造模式玩家无效

```yaml
- 'castSkill: 技能名称'
```

## 组合技记录

> 在对应组记录当前触发技能

```yaml
- 'combo: 触发组 触发ID'
```

语言描述较为抽象, 在此我以默认配置为例, 实现左键-右键-左键触发连击技的示范:

```yaml
ComboTest:
  left:
    sync:
      # 在ComboTest组记录, 触发了类型为left的连击
      - "combo: ComboTest left"
      # 检测ComboTest组是否完成了left-right-left连击
      - condition: combo("ComboTest", ["left", "right", "left"])
        actions:
          # 进行对应操作
          - 'tell: &e连击 &bL &f+ &bR &f+ &bL'
          # 已达成最终需要的连击, 清空ComboTest组的连击记录
          - 'comboClear: ComboTest'
        deny:
          # 检测ComboTest组是否完成了left连击
          condition: combo("ComboTest", ["left"])
          actions:
            # 进行对应操作
            - 'tell: &e连击 &bL'
  right:
    sync:
      # 在ComboTest组记录, 触发了类型为right的连击
      - "combo: ComboTest right"
      # 检测ComboTest组是否完成了left-right连击
      - condition: combo("ComboTest", ["left", "right"])
        actions:
          # 进行对应操作
          - 'tell: &e连击 &bL &f+ &bR'
```

## 组合技清除

> 清除对应组的技能记录

```yaml
- 'comboClear: 触发组'
```

## 设置药水效果

> 覆盖设置玩家身上的药水效果

```yaml
- 'setPotionEffect: 效果类型 效果等级 持续时长'
```

* `效果类型` 如`INCREASE_DAMAGE`代表力量, 详见 [点击查看药水效果大全](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/potion/PotionEffectType.html)

* `效果等级` 一个数字, 如`INCREASE_DAMAGE 1`代表力量1

* `持续时长` 一个数字, 如`INCREASE_DAMAGE 1 5`代表持续5秒的力量1

## 移除药水效果

> 移除玩家身上的药水效果

```yaml
- 'removePotionEffect: 效果类型'
```

* `效果类型` 如`INCREASE_DAMAGE`代表力量, 详见 [点击查看药水效果大全](https://hub.spigotmc.org/javadocs/spigot/org/bukkit/potion/PotionEffectType.html)

## 延时

> 延迟动作执行(单位是tick)

```yaml
- 'delay: 10'
```

## 终止

> 终止动作执行

```yaml
- 'return'
```

## JavaScript

> 执行一段javascript代码

```yaml
- 'js: player.sendMessage("你好")'
```

:::caution

不要在js动作中进行变量声明!!!

如: 
```js
test = 1
var test = 1
let test = 1
const test = 1
```


这将产生严重的线程安全问题

:::

对此, 我提供了替代方案:
将变量存放于默认提供的HashMap(可以通过`variables`或`vars`调用), 如:

```js
variables["test"] = 1
vars["test"] = 1
```

如果你想让一个变量传递到下一条js动作/condition中, 可以使用`global`(或`glo`)

```js
global["test"] = 1
glo["test"] = 1
```

js动作实际上与[动作条件](物品/物品动作/条件类型.md)运行于同一环境, 因此你可以使用动作条件中的所有对象/类/函数, 例如:

```js
// 调用player对象, 发送消息"你好"
player.sendMessage("你好")
```

## 设置Global

> 设置js动作中global的键值

```yaml
- 'setGlobal: 键 值'
```

之后可以在js中调用, 比如:

```yaml
- 'setGlobal: test 测试测试'
- 'js: print(global.test)'
```

后台将发送`测试测试`

## 移除Global

> 移除js动作中global的键值

```yaml
- 'delGlobal: 键'
```