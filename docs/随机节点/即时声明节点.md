---
sidebar_position: 2
---

# 即时声明节点

> 节点配置内全面支持节点调用/PAPI调用

## 格式

`<节点类型::参数1_参数2_参数3...>`

即时声明节点无法指定节点ID, 如有需求，请配置私有/全局节点

节点参数中的`_`请用`\_`代替, 避免被当做参数分隔符, 这里的反斜杠不是转义符, 因此请注意当前最外层括号的引号类型

yaml语法中双引号包裹的`\`代表转义符, `\\`才是反斜杠

单引号包裹的, 或没有引号包裹的`\`直接代表反斜杠

我在此列举所有情况, 供你参考:

```yaml
# 返回 test1 或 test2 或 test3
test1: <strings::test1_test2_test3>
# 返回 test1_test2 或 test3
test2: <strings::test1\_test2_test3>

# 返回 test1 或 test2 或 test3
test3: '<strings::test1_test2_test3>'
# 返回 test1_test2 或 test3
test4: '<strings::test1\_test2_test3>'

# 返回 test1 或 test2 或 test3
test5: "<strings::test1_test2_test3>"
# 返回 test1?test2 或 test3 此处的?是一种特殊字符, 代表被转义的_
test6: "<strings::test1\_test2_test3>"
# 返回 test1_test2 或 test3
test7: "<strings::test1\\_test2_test3>"
```

:::caution

很多情况下下, 对于连续的反斜杠, 最终呈现的数量为"总数/2"向上取整

比如连续三个反斜杠, 除以2等于1.5, 向上取整后体现为2个

连续四个反斜杠, 除以2等于2, 向上取整后也体现为2个(因为2本来就是整数)

对于这种奇葩的操作, 我写一段示例:

```yaml
# 获取出来是 \
test1: \
# 获取出来是 \
test2: \\
# 获取出来是 \\
test3: \\\
# 获取出来是 \
test4: '\'
# 获取出来是 \
test5: '\\'
# 获取出来是 \\
test6: '\\\'
# 获取出来是 \
test7: "\\"
# 获取出来是 \
test8: "\\\\"
# 获取出来是 \\
test9: "\\\\\\"
```

具体是否遇到这种奇葩情况, 需要你自己判断, 我在此仅作提醒

:::

## 字符串节点

```
<strings::测试字符串1_测试字符串2_测试字符串3>
```

string节点将在各参数中随机返回一个

## 随机数节点

```
<number::0_10_0_HALF_UP>
```

* `参数1` 随机数最小值
* `参数2` 随机数最大值
* `参数3` 保留小数位数(可不填写, 默认为0, 即不保留小数)
* `参数4` 取整模式(可不填写, 默认为`HALF_UP`, 即四舍五入)

如果你不想填写某个参数后的所有参数, 你可以直接将后面的参数省略, 比如: `<number::0_10>`代表一个0-10的随机整数

取整模式一览:

* `UP` 向远离0方向舍入
* `DOWN` 向0方向舍入
* `CEILING` 向正无穷方向舍入
* `FLOOR` 向负无穷方向舍入
* `HALF_UP` 通俗解释: 四舍五入; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向上舍入
* `HALF_DOWN` 通俗解释: 五舍六入; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向下舍入
* `HALF_EVEN` 通俗解释: 四舍六入五成双; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向偶数舍入

## Gaussian节点

```
<gaussian::100_0.1_0.5_1_0_10000>
```

* `参数1` 基础数值
* `参数2` 浮动单位
* `参数3` 浮动范围上限
* `参数4` 小数保留位数 (默认为1)
* `参数5` 随机数最小值 (可不填写)
* `参数6` 随机数最大值 (可不填写)
* `参数7` 取整模式(可不填写, 默认为`HALF_UP`, 即四舍五入)

取整模式一览:

* `UP` 向远离0方向舍入
* `DOWN` 向0方向舍入
* `CEILING` 向正无穷方向舍入
* `FLOOR` 向负无穷方向舍入
* `HALF_UP` 通俗解释: 四舍五入; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向上舍入
* `HALF_DOWN` 通俗解释: 五舍六入; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向下舍入
* `HALF_EVEN` 通俗解释: 四舍六入五成双; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向偶数舍入

关于Gaussian节点的详细介绍请看:

[Gaussian节点](随机节点/私有全局节点.md#gaussian节点)

## 公式节点

```
<calculation::1+1+3+<papi::player_level>_2_5_100_HALF_UP>
```

* `参数1` 计算公式
* `参数2` 保留小数位数(默认为0, 即不保留小数)
* `参数3` 公式结果最小值(默认不限制最小值)
* `参数4` 公式结果最大值(默认不限制最大值)
* `参数5` 取整模式(可不填写, 默认为`HALF_UP`, 即四舍五入)

如果你不想填写某个参数后的所有参数, 你可以直接将后面的参数省略, 比如你只想修改取整位数: `<calculation::1+1_1>`, 又或者你只想计算一个保留0位小数的公式: `<calculation::1+1>`

如果你不想填写中间的某个参数, 比如, 你不想限制结果的最大值和最小值, 但希望使用其他取整模式, 你可以直接将对应参数留空, 比如: `<calculation::-1.5____DOWN>`代表以`DOWN`取整模式将`-1.5`保留0位小数, 结果为`-1`

取整模式一览:

* `UP` 向远离0方向舍入
* `DOWN` 向0方向舍入
* `CEILING` 向正无穷方向舍入
* `FLOOR` 向负无穷方向舍入
* `HALF_UP` 通俗解释: 四舍五入; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向上舍入
* `HALF_DOWN` 通俗解释: 五舍六入; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向下舍入
* `HALF_EVEN` 通俗解释: 四舍六入五成双; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向偶数舍入

:::info

公式节点的本质是运行一段javascript代码

没有特殊需求应该优先使用快速计算(fastcalc)节点

:::

## 快速计算节点

```
<fastcalc::1+1+3+<papi::player_level>_2_5_100_HALF_UP>
```

* `参数1` 计算公式
* `参数2` 保留小数位数(可不填写, 默认为0, 即不保留小数)
* `参数3` 公式结果最小值(可不填写, 默认不限制最小值)
* `参数4` 公式结果最大值(可不填写, 默认不限制最大值)
* `参数5` 取整模式(可不填写, 默认为`HALF_UP`, 即四舍五入)

如果你不想填写某个参数后的所有参数, 你可以直接将后面的参数省略, 比如你只想修改取整位数: `<fastcalc::1+1_1>`, 又或者你只想计算一个保留0位小数的公式: `<fastcalc::1+1>`

如果你不想填写中间的某个参数, 比如, 你不想限制结果的最大值和最小值, 但希望使用其他取整模式, 你可以直接将对应参数留空, 比如: `<fastcalc::-1.5____DOWN>`代表以`DOWN`取整模式将`-1.5`保留0位小数, 结果为`-1`

取整模式一览:

* `UP` 向远离0方向舍入
* `DOWN` 向0方向舍入
* `CEILING` 向正无穷方向舍入
* `FLOOR` 向负无穷方向舍入
* `HALF_UP` 通俗解释: 四舍五入; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向上舍入
* `HALF_DOWN` 通俗解释: 五舍六入; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向下舍入
* `HALF_EVEN` 通俗解释: 四舍六入五成双; 详细解释: 向最接近的整数舍入, 如果距离两个整数相等, 则向偶数舍入

:::info

快速计算节点的本质是解析数学符号进行分析计算

计算速度高于公式节点

:::

## 权重节点

```
<weight::5::权重文本1_1::权重文本2>
```

参数格式 权重::权重文本

节点将根据权重随机返回一个权重文本

例如，在该示例节点中

将有5/6的几率返回"权重文本1"，1/6的几率返回"权重文本2"

## PAPI节点

```
<papi::player_name>
```

参数为待解析文本

:::tip

插件加载前或重载前，会先全局解析一次物品配置中的papi变量，将形如`%player_name%`的papi变量转换为`<papi::player_name>`。

因此一般来讲你可以直接写成`%player_name%`，我会帮你自动转换。

但对于经过拼接的papi文本，你还是得自己注意。

例如`<papi::<string-1><string-2>>`

`<string-1>`返回`player_`

`<string-2>`返回`name`

:::

## Javascript节点

```
<js::ExampleScript.js::main>
<js::ExampleScript.js::main_参数1_参数2_...>
```

参数格式 脚本路径::调用函数

或 脚本路径::调用函数\_参数1\_参数2\_...

## 渐变色节点

```
<gradient::000000_FFFFFF_1_哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈>
```

* `参数1` 起始颜色
* `参数2` 结尾颜色
* `参数3` 每几个字符变一次颜色
* `参数4` 文本内容

## 继承节点

```
<inherit::待继承节点ID>
```

如上，相当于继承了对应节点的所有内容。例如：

```yaml
sections:
  templateTest: <strings::text1_text2_text3>
```

```yaml
<inherit::templateTest>
```

其中`templateTest`有可能返回`text1`，`text2`或`text3`

即时声明节点`<inherit::templateTest>`同样有可能返回`text1`，`text2`或`text3`
