---
sidebar_position: 1
---

# 物品生成

NeigeItems会在开服后，以及ni reload之后，从配置文件中加载所有的物品配置。

## 配置继承

得到一段物品配置后，NeigeItems会先尝试读取inherit配置项，也就是继承配置项。

如果存在有关配置，就获取对应的物品，将需要继承的部分写入当前物品。比如：

```yaml
test1:
  material: IRON_SWORD

test2:
  inherit: test1
```

获取test2物品时，我们第一时间获取到的配置是这样的：

```yaml
test2:
  inherit: test1
```

然后我们读取inherit配置项，发现test2物品需要完全继承test1物品，于是读取对应内容并写入。

于是test2物品的配置将变为：

```yaml
test2:
  inherit: test1
  material: IRON_SWORD
```

## 全局节点调用

在继承工作完成后，物品会进行全局节点调用。

从全局节点库中查找是否存在对应的节点，如果存在，就将对应的节点写入当前物品配置。比如：

```yaml
# 物品配置文件
test:
  material: <材质>
  globalsections:
  - 材质
```

```yaml
# 全局节点配置文件
材质: <strings::STONE_DIAMOND>
```

获取test物品时，我们第一时间获取到的配置是这样的：

```yaml
test:
  material: <材质>
  globalsections:
  - 材质
```

进行全局节点解析后，物品配置将变为：

```yaml
test:
  material: <材质>
  sections:
    材质: <strings::STONE_DIAMOND>
```

经过配置继承和全局节点调用后，我们得到的配置，就是最终的物品配置。

## 静态配置项解析

NeigeItems存在一种静态(static)配置项的功能，static节点下的配置不会进行节点解析。

因此，将固定的配置挪到static节点下，将有效提升物品生成效率。

你可以通过后文了解“不进行节点解析”和“有效提升物品生成效率”二者之间的关系。

在经过配置继承和全局节点调用，得到最终的物品配置后，我们会先获取static节点，比如：

```yaml
test:
  material: <strings::STONE_DIAMOND>
  static:
    name: 你好
```

对于test物品，我们可以得到如下static节点：

```yaml
name: 你好
```

对于存在静态配置的物品，我们会根据静态配置生成一个模板物品，作为后续物品生成的基准物品。

比如对于上述test物品，基准物品将是一个名为“你好”的石头。

因为静态配置中没有配置物品材质，所以选取石头作为默认材质。

## 物品配置预处理

经过继承和全局节点调用后，我们得到了最终的物品配置。

在得到物品配置后，我们会先尝试解析static配置项，获取基准物品，然后将static配置项从配置中删除。

之后我们将sections配置项，即随机节点配置项从配置中拆出来，单独存储，并将sections配置项从配置中删除。

以上做的一切，都是为了尽可能缩小物品配置，让物品配置更短，这是为了节点解析做准备。

因为在这之后，我们要将配置项根据yaml语法转换为一段文本。

假如你的原始配置长这样：

```yaml
test:
  lore:
  - "<测试>"
  static:
    material: STONE
  sections:
    测试:
      type: join
      list:
        - 第一行
        - 第二行
        - 第三行
      separator: "\\n"
      prefix: '"'
      postfix: '"'
```

那么经过处理，最后我们获取的物品配置长这样：

```yaml
test:
  lore:
  - "<测试>"
```

但以上内容只是想象，因为这时候这段配置是以ConfigurationSection的形式存在于内存中的。

我们会在这之后将这段最终配置转换成文本，文本将形似：

```yaml
test:
  lore:
  - <测试>
```

注意到双引号消失了吗？因为这对双引号是非必须的，`<测试>`并不包含任何非法文本。

获取到以上文本后，这段文本将被缓存起来，等待获取物品时调用。

## 节点解析

经过预处理后，我们获取到了最终的物品配置文本。

在获取物品时，首先会进行节点解析。以上一节的示例物品为例：

```yaml
# 物品配置文本
test:
  lore:
  - <测试>
```

```yaml
# 节点配置
sections:
  测试:
    type: join
    list:
    - 第一行
    - 第二行
    - 第三行
    separator: "\\n"
    prefix: '"'
    postfix: '"'
```

对于这段配置文本：

```yaml
test:
  lore:
  - <测试>
```

我们会从前向后识别`<>`内容。识别到`测试`之后，先检测文本中是否包含`::`。

如果存在，就截取`::`前的文本作为即时节点类型，截取`::`后的文本作为即时节点参数，尝试进行即时节点解析。

如果不存在对应的节点类型，则返回原始文本。

如果文本中不存在`::`，首先尝试在缓存中读取对应节点的值，如果`测试`节点没有缓存，就在`sections`里查找名为`测试`的节点。

如果`sections`中存在名为`测试`的节点，再进行类型判断。

如果`测试`是简单节点，就对`测试`的内容进行节点解析，将解析内容存入缓存，再返回解析后内容。

如果`测试`是私有节点，就根据`测试`的内容获取尝试获取节点返回值并将返回值存入缓存。如果获取不到返回值，就返回原始文本。

如果`sections`中不存在名为`测试`的节点，尝试判断`测试`是否是`#`开头，如果是，尝试将`#`的文本转换为十六进制数，如果转换成功，就返回对应的RGB颜色。

因此，对于该物品，解析后的文本应该形似：

```yaml
test:
  lore:
  - "第一行\n第二行\n第三行"
```

`测试`节点将双引号作为前缀和后缀，将`\n`作为分隔符，将三段文本连接了起来。

进行节点解析之后，理应呈现上述的模样。

值得一提的是，如果分隔符不是`\n`文本，而是换行符`\n`，最后的配置就会变成这样：

```yaml
test:
  lore:
  - "第一行
第二行
第三行"
```

很弱智对吧。但没办法，事实就是这样。

## 指向数据的本质

引用上节内容：

:::info

如果文本中不存在`::`，首先尝试在缓存中读取对应节点的值，如果`测试`节点没有缓存，就在`sections`里查找名为`测试`的节点。

如果`sections`中存在名为`测试`的节点，再进行类型判断。

如果`测试`是简单节点，就对`测试`的内容进行节点解析，将解析内容存入缓存，再返回解析后内容。

如果`测试`是私有节点，就根据`测试`的内容获取尝试获取节点返回值并将返回值存入缓存。如果获取不到返回值，就返回原始文本。

:::

上述内容中提到了“在缓存中查找”、存入缓存......

所谓的指向数据，实际上就是预先将内容存入缓存。

等物品生成解析节点的时候，查到缓存里存在对应的内容，就不进行进一步操作了，直接返回就是了。

## 物品生成流程

物品生成的第一步就是根据最终配置文本进行节点解析，在此不再重复。

第二步就是根据解析后的文本，依据yaml语法，尝试读取物品配置。

如果你的物品配置出错了，后台就会报错。

这时候你可以开启config里的debug模式，查看解析后的文本，看看错误出在了哪里。

第三步就是根据解析出的物品配置生成物品。

首先，我们会判断配置中是否存在合格material配置项，或者静态配置中是否存在合格的material配置项

所谓“合格”是指material配置项能否转换为对应的物品材质。

比如STONE对应石头，而bvesabfwehf则不对应任何材质。前者合格，而后者不合格。

如果符合条件，代表这个物品配置配置了物品材质，而物品材质是一个物品生成的基础，配置了材质代表我们可以进一步生成这个物品。

首先，如果存在基准物品(即通过static配置项生成的物品)，就将基准物品复制一下，作为新物品的基础。

如果不存在基准物品，就根据material生成一个新物品。

然后在这个物品的基础上，读取各个配置项，设置物品的各个属性。

最后触发ItemGenerateEvent事件，再返回物品。

## 能否添加自定义配置项

不能，NeigeItems没有提供注册配置项的方法，你没有办法通过代码注册新的配置项，比如：

```yaml
test:
  material: STONE
  name: 测试
```

material配置项让将物品的材质设置为石头，将物品名设置为测试。

你无法自定义添加更多的配置项，对物品进行一些自定义操作。

因为我认为，NeigeItems自带的，材质、物品名、描述、附魔、NBT等配置项，已经覆盖了生成一个物品的所有需求。

善用随机节点可以让你写出你想要的任何物品。

## 我能不能异步获取物品

没问题，想异步就异步吧，没啥问题。
